<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>spring源码阅读(八)-----理解AOP | 不喝酒的烟</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">spring源码阅读(八)-----理解AOP</h1><a id="logo" href="/.">不喝酒的烟</a><p class="description">随便写写</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">spring源码阅读(八)-----理解AOP</h1><div class="post-meta">2021-01-07<span> | </span><span class="category"><a href="/categories/spring%E6%BA%90%E7%A0%81/">spring源码</a></span></div><a class="disqus-comment-count" href="/2021/01/07/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%85%AB)-----%E7%90%86%E8%A7%A3AOP/#vcomment"><span class="valine-comment-count" data-xid="/2021/01/07/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%85%AB)-----%E7%90%86%E8%A7%A3AOP/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">CGLIB动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-config%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">AOP config标签的解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#configureAutoProxyCreator-parserContext-element"><span class="toc-number">4.1.</span> <span class="toc-text">configureAutoProxyCreator(parserContext, element)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pointcut%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">pointcut属性解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#advisor"><span class="toc-number">4.3.</span> <span class="toc-text">advisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aspect"><span class="toc-number">4.4.</span> <span class="toc-text">aspect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ref%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.1.</span> <span class="toc-text">ref解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#before%EF%BC%8Cafter%EF%BC%8Caround%EF%BC%8Cafter-returning%EF%BC%8Cafter-throwing"><span class="toc-number">4.4.2.</span> <span class="toc-text">before，after，around，after-returning，after-throwing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%88%90AspectComponentDefinition"><span class="toc-number">4.4.3.</span> <span class="toc-text">组合成AspectComponentDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%A0%87%E7%AD%BE%E4%B8%8B%E9%9D%A2%E7%9A%84pointcut"><span class="toc-number">4.4.4.</span> <span class="toc-text">解析标签下面的pointcut</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E4%BB%A3%E7%90%86Bean%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">AOP代理Bean的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#postProcessBeforeInstantiation"><span class="toc-number">5.1.</span> <span class="toc-text">postProcessBeforeInstantiation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postProcessAfterInitialization%E5%92%8CgetEarlyBeanReference"><span class="toc-number">5.2.</span> <span class="toc-text">postProcessAfterInitialization和getEarlyBeanReference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JdkDynamicAopProxy"><span class="toc-number">5.2.1.</span> <span class="toc-text">JdkDynamicAopProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjenesisCglibAopProxy"><span class="toc-number">5.2.2.</span> <span class="toc-text">ObjenesisCglibAopProxy</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本章节，我们看看spring中AOP是如何实现的。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>spring中实现动态代理有两种方式。一种是JDK的动态代理，另一种是基于CGLIB的动态代理。给两个使用demo，不细讲。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><ol>
<li>Person接口<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">Person</span> &#123;</span><br><span class="line">	<span class="built_in">void</span> doThings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Person实现类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkingPerson</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打工人！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代理类<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonJdkProxy</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">Object</span> target;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="title">PersonJdkProxy</span>(<span class="params"><span class="built_in">Object</span> target</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">		before();</span><br><span class="line">		<span class="built_in">Object</span> result = method.invoke(target, args);</span><br><span class="line">		after();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">void</span> <span class="function"><span class="title">before</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">String</span>.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">void</span> <span class="function"><span class="title">after</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">String</span>.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line">public void jdk<span class="constructor">Test()</span>&#123;</span><br><span class="line">	Person person = <span class="keyword">new</span> <span class="constructor">WorkingPerson()</span>;</span><br><span class="line">	PersonJdkProxy jdkProxy = <span class="keyword">new</span> <span class="constructor">PersonJdkProxy(<span class="params">person</span>)</span>;</span><br><span class="line">	Person proxyPerson = (Person) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">person</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">ClassLoader()</span>,</span><br><span class="line">			person.get<span class="constructor">Class()</span>.get<span class="constructor">Interfaces()</span>,jdkProxy);</span><br><span class="line">	proxyPerson.<span class="keyword">do</span><span class="constructor">Things()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
JDK的动态代理需要有接口。<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3></li>
<li>EatingPerson不实现接口<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatingPerson</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">&quot;干饭人！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>CglibInterceptor拦截器<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> CglibInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 调用invoke方法之前执行</span><br><span class="line">	private <span class="type">void</span> <span class="keyword">before</span>() &#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(&quot;log start time [%s] &quot;, <span class="built_in">new</span> <span class="type">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	// 调用invoke方法之后执行</span><br><span class="line">	private <span class="type">void</span> <span class="keyword">after</span>() &#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(String.format(&quot;log end time [%s] &quot;, <span class="built_in">new</span> <span class="type">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Object</span> intercept(<span class="keyword">Object</span> obj, <span class="keyword">Method</span> <span class="keyword">method</span>, <span class="keyword">Object</span>[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">		<span class="keyword">before</span>();</span><br><span class="line">		<span class="keyword">Object</span> result = methodProxy.invokeSuper(obj, args);</span><br><span class="line">		<span class="keyword">after</span>();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line">public void cglib<span class="constructor">Test()</span>&#123;</span><br><span class="line">	Enhancer enhancer = <span class="keyword">new</span> <span class="constructor">Enhancer()</span>;</span><br><span class="line">	enhancer.set<span class="constructor">Superclass(EatingPerson.<span class="params">class</span>)</span>;</span><br><span class="line">	enhancer.set<span class="constructor">Callback(<span class="params">new</span> CglibInterceptor()</span>);</span><br><span class="line">	EatingPerson person = (EatingPerson) enhancer.create<span class="literal">()</span>;</span><br><span class="line">	person.<span class="keyword">do</span><span class="constructor">Things()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
CGLIB代理不依赖接口。</li>
</ol>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>spring3.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       	http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;mypointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *.send())&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logAspectConfig&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;mypointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;mypointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;mypointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.springframework.mytest&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>LogAspectConfig<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LogAspectConfig &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> <span class="keyword">before</span>(JoinPoint joinPoint)&#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;LogAspectConfig before!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">		long start = <span class="keyword">System</span>.currentTimeMillis();</span><br><span class="line">		joinPoint.proceed();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;LogAspectConfig around!Cost &quot; + (<span class="keyword">System</span>.currentTimeMillis() - <span class="keyword">start</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> <span class="keyword">after</span>()&#123;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;LogAspectConfig after!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试ClassPathXmlApplicationTest<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">classPathXml10</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		BeanFactory bf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring3.xml&quot;</span>);</span><br><span class="line">		ConfigBean2 bean = (ConfigBean2) bf.getBean(<span class="string">&quot;configBean2&quot;</span>);</span><br><span class="line">		bean.send();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">classPathXml11</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		BeanFactory bf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring3.xml&quot;</span>);</span><br><span class="line">		ConfigBean1 bean = (ConfigBean1) bf.getBean(<span class="string">&quot;configBean1&quot;</span>);</span><br><span class="line">		bean.send();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="AOP-config标签的解析"><a href="#AOP-config标签的解析" class="headerlink" title="AOP config标签的解析"></a>AOP config标签的解析</h2><p>同样的步骤，找到aop命名空间config标签的解析类ConfigBeanDefinitionParser。ConfigBeanDefinitionParser定义了很多static final String。这些都是config可配置的属性，我们来看看各项配置的解析过程。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ConfigBeanDefinitionParser</span>.</span></span><span class="keyword">class</span></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">		CompositeComponentDefinition compositeDef =</span><br><span class="line">				<span class="keyword">new</span> <span class="constructor">CompositeComponentDefinition(<span class="params">element</span>.<span class="params">getTagName</span>()</span>, parserContext.extract<span class="constructor">Source(<span class="params">element</span>)</span>);</span><br><span class="line">		parserContext.push<span class="constructor">ContainingComponent(<span class="params">compositeDef</span>)</span>;</span><br><span class="line"></span><br><span class="line">		configure<span class="constructor">AutoProxyCreator(<span class="params">parserContext</span>, <span class="params">element</span>)</span>;</span><br><span class="line"></span><br><span class="line">		List&lt;Element&gt; childElts = <span class="module-access"><span class="module"><span class="identifier">DomUtils</span>.</span></span>get<span class="constructor">ChildElements(<span class="params">element</span>)</span>;</span><br><span class="line">		<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">			String localName = parserContext.get<span class="constructor">Delegate()</span>.get<span class="constructor">LocalName(<span class="params">elt</span>)</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">POINTCUT</span>.</span></span>equals(localName)) &#123;</span><br><span class="line">				parse<span class="constructor">Pointcut(<span class="params">elt</span>, <span class="params">parserContext</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">ADVISOR</span>.</span></span>equals(localName)) &#123;</span><br><span class="line">				parse<span class="constructor">Advisor(<span class="params">elt</span>, <span class="params">parserContext</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">ASPECT</span>.</span></span>equals(localName)) &#123;</span><br><span class="line">				parse<span class="constructor">Aspect(<span class="params">elt</span>, <span class="params">parserContext</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.pop<span class="constructor">AndRegisterContainingComponent()</span>;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>new了一个name为aop:config的CompositeComponentDefinition，CompositeComponentDefinition就是多个ComponentDefinition的集合。</p>
<h3 id="configureAutoProxyCreator-parserContext-element"><a href="#configureAutoProxyCreator-parserContext-element" class="headerlink" title="configureAutoProxyCreator(parserContext, element)"></a>configureAutoProxyCreator(parserContext, element)</h3><p>configureAutoProxyCreator(parserContext, element)会调用工具类AopNamespaceUtils的registerAspectJAutoProxyCreatorIfNecessary方法。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">public</span> static <span class="type">void</span> registerAspectJAutoProxyCreatorIfNecessary(</span><br><span class="line">		ParserContext parserContext, Element sourceElement) &#123;</span><br><span class="line">       // 注册名为org.springframework.aop.config.internalAutoProxyCreator的beanDefinition，其中的<span class="keyword">class</span>类为`AspectJAwareAdvisorAutoProxyCreator`</span><br><span class="line">	BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(</span><br><span class="line">			parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">	// 如果指定proxy-target-<span class="keyword">class</span>=<span class="keyword">true</span>，将proxyTargetClass值为<span class="keyword">true</span>的属性添加到BeanDefinition中,此时会强制使用CGLIB代理</span><br><span class="line">	// 如果指定expose-proxy=<span class="keyword">true</span>，将exposeProxy值为<span class="keyword">true</span>的属性添加到BeanDefinition中,此时会暴露代理，解决了服务内部方法互相调用，内部方法AOP不生效的问题</span><br><span class="line">	useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">	registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AspectJAwareAdvisorAutoProxyCreator是一个SmartInstantiationAwareBeanPostProcessor，我们再讲@Autowired注解的时候，提到过BeanPostProcessor的继承体系，实现SmartInstantiationAwareBeanPostProcessor需要实现8个方法，每个方法在哪里使用都有提过，稍后我们会讲到AspectJAwareAdvisorAutoProxyCreator。<br>如果指定proxy-target-class=true，将proxyTargetClass值为true的属性添加到BeanDefinition中,此时会强制使用CGLIB代理，否则会发根据其他条件判断使用哪种代理。<br>如果指定expose-proxy=true，将exposeProxy值为true的属性添加到BeanDefinition中,此时会暴露代理，解决了服务内部方法互相调用，内部方法AOP不生效的问题。这里比较难理解，比如我们在某个服务的方法里面使用了本身带有@Transacitonal注解的方法，此时@Transacitonal注解是没有生效的，因为内部调用不会走代理。如果exposeProxy值设置为true，就可以让内部方法调用成功。  </p>
<h3 id="pointcut属性解析"><a href="#pointcut属性解析" class="headerlink" title="pointcut属性解析"></a>pointcut属性解析</h3><p>pointcut会被解析成一个带有expression属性的RootBeanDefinition，表示一个AspectJExpressionPointcut类，注册到容器中。同时会在CompositeComponentDefinition中加入一个PointcutComponentDefinition。</p>
<h3 id="advisor"><a href="#advisor" class="headerlink" title="advisor"></a>advisor</h3><p>advisor的解析比较简单，就是创建了一个DefaultBeanFactoryPointcutAdvisor的RootBeanDefinition。</p>
<h3 id="aspect"><a href="#aspect" class="headerlink" title="aspect"></a>aspect</h3><h4 id="ref解析"><a href="#ref解析" class="headerlink" title="ref解析"></a>ref解析</h4><p>首先会将ref属性解析为一个RuntimeBeanReference，放入临时变量beanReferences中。</p>
<h4 id="before，after，around，after-returning，after-throwing"><a href="#before，after，around，after-returning，after-throwing" class="headerlink" title="before，after，around，after-returning，after-throwing"></a>before，after，around，after-returning，after-throwing</h4><p>然后会将before，after，around，after-returning，after-throwing解析成RootBeanDefinition，并放入临时变量beanDefinitions中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">parseAdvice</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">		String aspectName, <span class="built_in">int</span> order, Element aspectElement, Element adviceElement, ParserContext parserContext,</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create the method factory bean</span></span><br><span class="line">		RootBeanDefinition methodDefinition = <span class="keyword">new</span> RootBeanDefinition(MethodLocatingFactoryBean.<span class="keyword">class</span>);</span><br><span class="line">		methodDefinition.getPropertyValues().<span class="keyword">add</span>(<span class="string">&quot;targetBeanName&quot;</span>, aspectName);</span><br><span class="line">		methodDefinition.getPropertyValues().<span class="keyword">add</span>(<span class="string">&quot;methodName&quot;</span>, adviceElement.getAttribute(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">		methodDefinition.setSynthetic(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create instance factory definition</span></span><br><span class="line">		RootBeanDefinition aspectFactoryDef =</span><br><span class="line">				<span class="keyword">new</span> RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.<span class="keyword">class</span>);</span><br><span class="line">		aspectFactoryDef.getPropertyValues().<span class="keyword">add</span>(<span class="string">&quot;aspectBeanName&quot;</span>, aspectName);</span><br><span class="line">		aspectFactoryDef.setSynthetic(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// register the pointcut</span></span><br><span class="line">		AbstractBeanDefinition adviceDef = createAdviceDefinition(</span><br><span class="line">				adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,</span><br><span class="line">				beanDefinitions, beanReferences);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// configure the advisor</span></span><br><span class="line">		RootBeanDefinition advisorDefinition = <span class="keyword">new</span> RootBeanDefinition(AspectJPointcutAdvisor.<span class="keyword">class</span>);</span><br><span class="line">		advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">		advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line">		<span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">			advisorDefinition.getPropertyValues().<span class="keyword">add</span>(</span><br><span class="line">					ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// register the final advisor</span></span><br><span class="line">		parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> advisorDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建MethodLocatingFactoryBean的RootBeanDefinition</li>
<li>创建SimpleBeanFactoryAwareAspectInstanceFactory的RootBeanDefinition</li>
<li>组合创建RootBeanDefinition<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private AbstractBeanDefinition createAdviceDefinition(</span><br><span class="line">			Element adviceElement, ParserContext parserContext, String aspectName, int <span class="keyword">order,</span></span><br><span class="line"><span class="keyword">	</span>		RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,</span><br><span class="line">			List&lt;<span class="keyword">BeanDefinition&gt; </span><span class="keyword">beanDefinitions, </span>List&lt;<span class="keyword">BeanReference&gt; </span><span class="keyword">beanReferences) </span>&#123;</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition adviceDefinition = new RootBeanDefinition(getAdviceClass(adviceElement, parserContext));</span><br><span class="line">		adviceDefinition.setSource(parserContext.<span class="keyword">extractSource(adviceElement));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">	</span>	adviceDefinition.getPropertyValues().<span class="keyword">add(ASPECT_NAME_PROPERTY, </span>aspectName);</span><br><span class="line">		adviceDefinition.getPropertyValues().<span class="keyword">add(DECLARATION_ORDER_PROPERTY, </span><span class="keyword">order);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">	</span>	if (adviceElement.hasAttribute(RETURNING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().<span class="keyword">add(</span></span><br><span class="line"><span class="keyword">	</span>				RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));</span><br><span class="line">		&#125;</span><br><span class="line">		if (adviceElement.hasAttribute(THROWING)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().<span class="keyword">add(</span></span><br><span class="line"><span class="keyword">	</span>				THROWING_PROPERTY, adviceElement.getAttribute(THROWING));</span><br><span class="line">		&#125;</span><br><span class="line">		if (adviceElement.hasAttribute(ARG_NAMES)) &#123;</span><br><span class="line">			adviceDefinition.getPropertyValues().<span class="keyword">add(</span></span><br><span class="line"><span class="keyword">	</span>				ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();</span><br><span class="line">		cav.<span class="keyword">addIndexedArgumentValue(METHOD_INDEX, </span>methodDef);</span><br><span class="line"></span><br><span class="line">		Object pointcut = parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">		if (pointcut <span class="keyword">instanceof </span><span class="keyword">BeanDefinition) </span>&#123;</span><br><span class="line">			cav.<span class="keyword">addIndexedArgumentValue(POINTCUT_INDEX, </span>pointcut);</span><br><span class="line">			<span class="keyword">beanDefinitions.add((BeanDefinition) </span>pointcut);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (pointcut <span class="keyword">instanceof </span>String) &#123;</span><br><span class="line">			RuntimeBeanReference pointcutRef = new RuntimeBeanReference((String) pointcut);</span><br><span class="line">			cav.<span class="keyword">addIndexedArgumentValue(POINTCUT_INDEX, </span>pointcutRef);</span><br><span class="line">			<span class="keyword">beanReferences.add(pointcutRef);</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line"></span><br><span class="line">		cav.<span class="keyword">addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, </span>aspectFactoryDef);</span><br><span class="line"></span><br><span class="line">		return adviceDefinition;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
这一步根据aop:aspect下各个标签的写法，创建不同class的RootBeanDefinition。before，after，around，after-returning，after-throwing分别对应AspectJMethodBeforeAdvice，AspectJAfterAdvice，AspectJAroundAdvice，AspectJAfterReturningAdvice和AspectJAfterThrowingAdvice。<br>再解析各种属性，比如arg-names。<br>再解析ConstructorArgumentValues。<br>这样解析完，AspectJMethodBeforeAdvice的BeanDefinition就有三个构造方法了。</li>
<li>创建AspectJPointcutAdvisor的RootBeanDefinition，并注册<h4 id="组合成AspectComponentDefinition"><a href="#组合成AspectComponentDefinition" class="headerlink" title="组合成AspectComponentDefinition"></a>组合成AspectComponentDefinition</h4>将所有的beanDefinitions和beanReferences组合成为一个AspectComponentDefinition。<h4 id="解析标签下面的pointcut"><a href="#解析标签下面的pointcut" class="headerlink" title="解析标签下面的pointcut"></a>解析标签下面的pointcut</h4>如果aspect下面也配置有pointcut，对其进行解析。</li>
</ol>
<h2 id="AOP代理Bean的生成"><a href="#AOP代理Bean的生成" class="headerlink" title="AOP代理Bean的生成"></a>AOP代理Bean的生成</h2><p>代理类会被AspectJAwareAdvisorAutoProxyCreator后置处理器处理。<br>AspectJAwareAdvisorAutoProxyCreator是一个SmartInstantiationAwareBeanPostProcessor，理论上需要实现8个方法。但是AspectJAwareAdvisorAutoProxyCreator实际上只有3个方法的实现是有实际意义的。postProcessBeforeInstantiation是在实例化之前调用，postProcessAfterInitialization实在初始化之后调用，getEarlyBeanReference是在getSingleton里面调用。</p>
<h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">	Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 自定义TargetSourceCreator，一般为空</span></span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这一段，其实就是把Advice，Pointcut，Advisor，AopInfrastructureBean的实现类放入advisedBeans缓存起来，这些接口的实现类在后置处理时是不会走代理，而是直接返回bean的。</p>
<h3 id="postProcessAfterInitialization和getEarlyBeanReference"><a href="#postProcessAfterInitialization和getEarlyBeanReference" class="headerlink" title="postProcessAfterInitialization和getEarlyBeanReference"></a>postProcessAfterInitialization和getEarlyBeanReference</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public Object postProcessAfterInitialization(@Nullable Object <span class="keyword">bean, </span>String <span class="keyword">beanName) </span>throws <span class="keyword">BeansException </span>&#123;</span><br><span class="line">	if (<span class="keyword">bean </span>!= null) &#123;</span><br><span class="line">		Object <span class="keyword">cacheKey </span>= getCacheKey(<span class="keyword">bean.getClass(), </span><span class="keyword">beanName);</span></span><br><span class="line"><span class="keyword">	</span>	if (this.earlyProxyReferences.remove(<span class="keyword">cacheKey) </span>!= <span class="keyword">bean) </span>&#123;</span><br><span class="line">			return wrapIfNecessary(<span class="keyword">bean, </span><span class="keyword">beanName, </span><span class="keyword">cacheKey);</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="keyword">bean;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">@Override</span></span><br><span class="line"><span class="keyword">public </span>Object getEarlyBeanReference(Object <span class="keyword">bean, </span>String <span class="keyword">beanName) </span>throws <span class="keyword">BeansException </span>&#123;</span><br><span class="line">	Object <span class="keyword">cacheKey </span>= getCacheKey(<span class="keyword">bean.getClass(), </span><span class="keyword">beanName);</span></span><br><span class="line"><span class="keyword">	</span>this.earlyProxyReferences.put(<span class="keyword">cacheKey, </span><span class="keyword">bean);</span></span><br><span class="line"><span class="keyword">	</span>return wrapIfNecessary(<span class="keyword">bean, </span><span class="keyword">beanName, </span><span class="keyword">cacheKey);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>postProcessAfterInitialization和getEarlyBeanReference逻辑几乎一样，就是一个是放入earlyProxyReferences缓存，一个是移除earlyProxyReferences缓存。重点还是wrapIfNecessary(bean, beanName, cacheKey)方法。  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="built_in">Object</span> <span class="function"><span class="title">wrapIfNecessary</span>(<span class="params"><span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName, <span class="built_in">Object</span> cacheKey</span>)</span> &#123;</span><br><span class="line">	……</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	<span class="built_in">Object</span>[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="built_in">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line">		<span class="built_in">Object</span> proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)就是根据expression找到对应的Advisor。每个Advisor都有一个advice和一个pointcut，和我们的配置文件一样，method会被解析为对应的advice,pointcut-ref会被解析为一个的ComposablePointcut。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">AbstractAdvisorAutoProxyCreator</span>.</span></span><span class="keyword">class</span></span><br><span class="line"></span><br><span class="line">    protected List&lt;Advisor&gt; find<span class="constructor">EligibleAdvisors(Class&lt;?&gt; <span class="params">beanClass</span>, String <span class="params">beanName</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化所有的Advidor</span></span><br><span class="line">		List&lt;Advisor&gt; candidateAdvisors = find<span class="constructor">CandidateAdvisors()</span>;</span><br><span class="line">		<span class="comment">// 找到匹配的Advidor</span></span><br><span class="line">		List&lt;Advisor&gt; eligibleAdvisors = find<span class="constructor">AdvisorsThatCanApply(<span class="params">candidateAdvisors</span>, <span class="params">beanClass</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line">		extend<span class="constructor">Advisors(<span class="params">eligibleAdvisors</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!eligibleAdvisors.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">			eligibleAdvisors = sort<span class="constructor">Advisors(<span class="params">eligibleAdvisors</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		return eligibleAdvisors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在所有初始化的Advidor中找到匹配的Advisor，调用的是AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AopUtils.class</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="function"><span class="title">findAdvisorsThatCanApply</span>(<span class="params">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">				eligibleAdvisors.add(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">		<span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				<span class="comment">// already processed</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">				eligibleAdvisors.add(candidate);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Advisor有分为很多类别，这里单独把引介增强IntroductionAdvisor先处理，然后处理其他Advisor。IntroductionAdvisor是一种比较我们接触的比较少的增强，我们可以在以后的文章单独做个分析，暂时跳过。普通Advisor能否匹配上，主要靠Advisor的PointCut来判断，也就是Advisor里面的ComposablePointcut。它有两个属性，一个ClassFilter，一个methodMatcher。<br>MethodMatcher中有两个matches方法。一个参数是只有Method对象和targetclass，另一个参数有Method对象和targetClass对象还有一个Method的方法参数 他们两个的区别是：两个参数的matches是用于静态的方法匹配 三个参数的matches是在运行期动态的进行方法匹配。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static boolean can<span class="constructor">Apply(Pointcut <span class="params">pc</span>, Class&lt;?&gt; <span class="params">targetClass</span>, <span class="params">boolean</span> <span class="params">hasIntroductions</span>)</span> &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Null(<span class="params">pc</span>, <span class="string">&quot;Pointcut must not be null&quot;</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (!pc.get<span class="constructor">ClassFilter()</span>.matches(targetClass)) &#123;</span><br><span class="line">			return <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MethodMatcher methodMatcher = pc.get<span class="constructor">MethodMatcher()</span>;</span><br><span class="line">		<span class="keyword">if</span> (methodMatcher<span class="operator"> == </span>MethodMatcher.TRUE) &#123;</span><br><span class="line">			<span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;</span><br><span class="line">		<span class="keyword">if</span> (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>is<span class="constructor">ProxyClass(<span class="params">targetClass</span>)</span>) &#123;</span><br><span class="line">			classes.add(<span class="module-access"><span class="module"><span class="identifier">ClassUtils</span>.</span></span>get<span class="constructor">UserClass(<span class="params">targetClass</span>)</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		classes.add<span class="constructor">All(ClassUtils.<span class="params">getAllInterfacesForClassAsSet</span>(<span class="params">targetClass</span>)</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">			Method<span class="literal">[]</span> methods = <span class="module-access"><span class="module"><span class="identifier">ReflectionUtils</span>.</span></span>get<span class="constructor">AllDeclaredMethods(<span class="params">clazz</span>)</span>;</span><br><span class="line">			<span class="keyword">for</span> (Method <span class="keyword">method</span> : methods) &#123;</span><br><span class="line">				<span class="keyword">if</span> (introductionAwareMethodMatcher != null ?</span><br><span class="line">						introductionAwareMethodMatcher.matches(<span class="keyword">method</span>, targetClass, hasIntroductions) :</span><br><span class="line">						methodMatcher.matches(<span class="keyword">method</span>, targetClass)) &#123;</span><br><span class="line">					return <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>关于匹配这一块逻辑，涉及到aspectj里面的逻辑，有些复杂，想了的请移步aspectj。<br>找到匹配的Advisor之后，extendAdvisors(eligibleAdvisors)会在list里面增加ExposeInvocationInterceptor，并按照一定规则排序。<br>接下来就是创建代理类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="built_in">Object</span> createProxy(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> <span class="built_in">String</span> beanName,</span><br><span class="line">		<span class="meta">@Nullable</span> <span class="built_in">Object</span>[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">	    <span class="comment">// 设置originalTargetClass</span></span><br><span class="line">		AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">	<span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">	proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">       </span><br><span class="line">	<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">	    <span class="comment">// 决定对于给定的bean是否应该使用targetClass而不是他的接口代理</span></span><br><span class="line">           <span class="comment">// 检査 proxyTargetClass 设置以及 preserveTargetClass 属性</span></span><br><span class="line">		<span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">	proxyFactory.addAdvisors(advisors);</span><br><span class="line">	proxyFactory.setTargetSource(targetSource);</span><br><span class="line">	customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">	proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">	<span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">		proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码前面都是在给roxyFactory设置属性，为了正真的代理创建做准备工作。正在创建代理的方法是proxyFactory.getProxy(getProxyClassLoader())中，ProxyFactory又委托DefaultAopProxyFactory根据条件创建AopProxy，最终AopProxy正在的创建代理。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport <span class="built_in">config</span>)</span> throws AopConfigException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = <span class="built_in">config</span>.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">					<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(<span class="built_in">config</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，有接口，就使用JdkDynamicAopProxy，没有就使用ObjenesisCglibAopProxy，当然并不是绝对的。<br>jdk的动态代理逻辑，比较容易理解，就是我们上面讲解的流程。主要是给当前类又增加了两个接口：SpringProxy是一个标记接口，Advised比较复杂，ProxyFactory就是他的是实现类。jdk的动态代理，主要执行是在invoke方法里面。</p>
<h4 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line">		……</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.get<span class="constructor">InterceptorsAndDynamicInterceptionAdvice(<span class="params">method</span>, <span class="params">targetClass</span>)</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line">			<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">			<span class="keyword">if</span> (chain.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">				<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">				<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">				<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">				Object<span class="literal">[]</span> argsToUse = <span class="module-access"><span class="module"><span class="identifier">AopProxyUtils</span>.</span></span>adapt<span class="constructor">ArgumentsIfNecessary(<span class="params">method</span>, <span class="params">args</span>)</span>;</span><br><span class="line">				retVal = <span class="module-access"><span class="module"><span class="identifier">AopUtils</span>.</span></span>invoke<span class="constructor">JoinpointUsingReflection(<span class="params">target</span>, <span class="params">method</span>, <span class="params">argsToUse</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">				MethodInvocation invocation =</span><br><span class="line">						<span class="keyword">new</span> <span class="constructor">ReflectiveMethodInvocation(<span class="params">proxy</span>, <span class="params">target</span>, <span class="params">method</span>, <span class="params">args</span>, <span class="params">targetClass</span>, <span class="params">chain</span>)</span>;</span><br><span class="line">				<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">				retVal = invocation.proceed<span class="literal">()</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			……</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>equals和hashcode方法以及某些接口的方法会单独处理，不单独说。对于匹配我们定义的Advisor的方法，会构造一个MethodInvocation，invocation.proceed()从模式上来说可以看作一个责任链，也可以简单理解为一个递归调用，每一个MethodInterceptor都会调用自己的invoke方法。  </p>
<h4 id="ObjenesisCglibAopProxy"><a href="#ObjenesisCglibAopProxy" class="headerlink" title="ObjenesisCglibAopProxy"></a>ObjenesisCglibAopProxy</h4><p>CGLIB主要起作用的地方在Callback里面。此处也是按顺序一责任链的方式调用。<br>spring里面Callback有以下几种子接口：</p>
<ol>
<li>MethodInterceptor<br>它只有一个方法public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,<br>MethodProxy proxy) throws Throwable，主要是对方法做拦截代理。</li>
<li>NoOp<br>不做任何其它的操作</li>
<li>LazyLoader<br>LazyLoader，它也提供了一个方法：Object loadObject() throws Exception，loadObject()方法会在第一次被代理类的方法调用时触发，它返回一个代理类的对象，这个对象会被存储起来然后负责所有被代理类方法的调用，就像它的名字说的那样，一种lazy模式。如果被代理类或者代理类的对象的创建比较麻烦，而且不确定它是否会被使用，那么可以选择使用这种lazy模式来延迟生成代理。</li>
<li>Dispatcher<br>Dispatcher和LazyLoader接口相同，也是提供了loadObject()方法，这个方法同样地返回一个代理对象，这个对象同样可以代理原方法的调用。不过它们之间不同的地方在于，Dispatcher的loadObject()方法在每次发生对原方法的调用时都会被调用并返回一个代理对象来调用原方法。也就是说Dispatcher的loadObject()方法返回的对象并不会被存储起来，可以类比成Spring中的Prototype类型，而LazyLoader则是lazy模式的Singleton。</li>
<li>InvocationHandler<br>与MethodInterceptor相似</li>
<li>FixedValue<br>返回一个固定值  </li>
</ol>
<p>这里看看我们的Enhancer里面添加了哪些Callbacks:<br><img src="https://cdn.jsdelivr.net/gh/engimatic/privateimage@main/img/callbacks.png"><br>然后又给Enhancer设置了一个ProxyCallbackFilter，它是一个CallbackFilter，在Enhancer的作用是决定哪些方法使用哪个Callback，通过返回的下表来决定。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_TARGET = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_OVERRIDE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_TARGET = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_ADVISED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_EQUALS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_HASHCODE = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>这下下标和Callbacks一一对应，主要由ProxyCallbackFilter的int accept(Method method)方法来控制。我们的切面都是通过DynamicAdvisedInterceptor来实现的。DynamicAdvisedInterceptor的intercept和jdk的invoke很相似，构造了一个CglibMethodInvocation，来递归调用所有的MethodInterceptor，调用顺序和jdk代理的调用顺序一摸一样。看下面的代码，是不是和JdkDynamicAopProxy的invoke很相似。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DynamicAdvisedInterceptor</span>.</span></span><span class="keyword">class</span></span><br><span class="line">    @Override</span><br><span class="line">		@Nullable</span><br><span class="line">		public Object intercept(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">			……</span><br><span class="line">				List&lt;Object&gt; chain = this.advised.get<span class="constructor">InterceptorsAndDynamicInterceptionAdvice(<span class="params">method</span>, <span class="params">targetClass</span>)</span>;</span><br><span class="line">				Object retVal;</span><br><span class="line">				<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">				<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">				<span class="keyword">if</span> (chain.is<span class="constructor">Empty()</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Public(<span class="params">method</span>.<span class="params">getModifiers</span>()</span>)) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object<span class="literal">[]</span> argsToUse = <span class="module-access"><span class="module"><span class="identifier">AopProxyUtils</span>.</span></span>adapt<span class="constructor">ArgumentsIfNecessary(<span class="params">method</span>, <span class="params">args</span>)</span>;</span><br><span class="line">					retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> <span class="constructor">CglibMethodInvocation(<span class="params">proxy</span>, <span class="params">target</span>, <span class="params">method</span>, <span class="params">args</span>, <span class="params">targetClass</span>, <span class="params">chain</span>, <span class="params">methodProxy</span>)</span>.proceed<span class="literal">()</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = process<span class="constructor">ReturnType(<span class="params">proxy</span>, <span class="params">target</span>, <span class="params">method</span>, <span class="params">retVal</span>)</span>;</span><br><span class="line">				return retVal;</span><br><span class="line">			&#125;</span><br><span class="line">			……</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>至于调用顺序是什么样的，大致如下，就不细说了。<br><img src="https://cdn.jsdelivr.net/gh/engimatic/privateimage@main/img/process.png"></p>
</div><div class="tags"><a href="/tags/spring/"><i class="fa fa-tag"></i>spring</a><a href="/tags/%E6%BA%90%E7%A0%81/"><i class="fa fa-tag"></i>源码</a><a href="/tags/%E6%9E%B6%E6%9E%84/"><i class="fa fa-tag"></i>架构</a></div><div class="post-nav"><a class="pre" href="/2021/03/11/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%8D%81)-----SpringBoot%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E7%BD%AETomcat/">spring源码阅读(一)-----核心流程</a><a class="next" href="/2020/12/30/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%83)-----%E7%90%86%E8%A7%A3@Configuration/">spring源码阅读(七)-----理解@Configuration</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'m1L4QofvaTBynd4G4ARXUBIv-gzGzoHsz',
  appKey:'q7tSFtGgIvgO1ScyMtQdvUkR',
  placeholder:'Just so so',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10'
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/spring%E6%BA%90%E7%A0%81/">spring源码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 15px;">源码</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 15px;">架构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/11/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%8D%81)-----SpringBoot%E5%90%AF%E5%8A%A8%E5%92%8C%E5%86%85%E7%BD%AETomcat/">spring源码阅读(一)-----核心流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/07/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%85%AB)-----%E7%90%86%E8%A7%A3AOP/">spring源码阅读(八)-----理解AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/30/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%83)-----%E7%90%86%E8%A7%A3@Configuration/">spring源码阅读(七)-----理解@Configuration</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/20/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%85%AD)-----ClassPathXmlApplicationContext%E6%B5%81%E7%A8%8B/">spring源码阅读(六)-----ClassPathXmlApplicationContext流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/18/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%BA%94)-----%E7%90%86%E8%A7%A3@Component/">spring源码阅读(五)-----理解@Component</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/16/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%9B%9B)-----%E7%90%86%E8%A7%A3@Autowired/">spring源码阅读(四)-----理解@Autowired</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/14/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%89)-----Bean%E7%9A%84%E5%8A%A0%E8%BD%BD/">spring源码阅读(三)-----Bean的加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/01/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%BA%8C)-----BeanDefinition%E7%9A%84%E6%B3%A8%E5%86%8C/">spring源码阅读(二)-----资源加载与BeanDefinition注册</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/01/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E4%B8%80)-----%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">spring源码阅读(一)-----核心流程</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">不喝酒的烟.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":350,"height":650},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>